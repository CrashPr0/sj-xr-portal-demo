<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Mock WebAR Geo Spawn (Camera + GPS)</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    #hud {
      position: fixed;
      top: 0; left: 0;
      z-index: 10;
      padding: 10px;
      color: #00ff66;
      font-size: 12px;
      line-height: 1.25;
      white-space: pre-wrap;
      text-shadow: 0 0 3px rgba(0,0,0,.85);
      background: rgba(0,0,0,.35);
      max-width: 92vw;
      max-height: 70vh;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    #startOverlay {
      position: fixed;
      inset: 0;
      z-index: 20;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,.86);
      color: #fff;
    }
    #startOverlay button {
      font-size: 18px;
      padding: 14px 18px;
      border-radius: 12px;
      border: 0;
    }
    #startOverlay .small {
      margin-top: 12px;
      font-size: 12px;
      opacity: 0.85;
      max-width: 72vw;
      line-height: 1.35;
    }

    /* IMPORTANT: keep the <video> in the DOM (NOT display:none).
       iOS can refuse to advance frames / textures if the video is display:none. */
    #camVideo {
      position: fixed;
      width: 1px; height: 1px;
      left: -9999px; top: -9999px;
      opacity: 0.01;
      background: #000;
    }

    a-scene {
      position: fixed !important;
      inset: 0 !important;
      z-index: 5;
    }
  </style>
</head>

<body>
  <div id="hud">Loading…</div>

  <div id="startOverlay">
    <div style="text-align:center; padding:20px;">
      <button id="startBtn">Start Camera + GPS</button>
      <div class="small">
        iOS/Safari requires a tap to start camera. Accept both Camera + Location prompts.
        HUD shows exact getUserMedia errors + camera stream state.
      </div>
    </div>
  </div>

  <!-- Video element that holds the camera stream (used as a WebGL texture) -->
  <video id="camVideo" playsinline webkit-playsinline muted autoplay></video>

  <a-scene
    id="scene"
    embedded
    vr-mode-ui="enabled:false"
    renderer="alpha:true; antialias:true; precision:mediump; powerPreference:high-performance"
    background="color: #000000">

    <!-- Camera -->
    <a-camera id="cam" position="0 0 0" fov="80"
      look-controls="enabled:true"
      wasd-controls="enabled:false"></a-camera>

    <!-- Camera feed plane (we size it in JS once we know video aspect ratio) -->
    <a-plane id="bgPlane"
      position="0 0 -10"
      width="16" height="9"
      material="shader: flat; src: #camVideo; side: double"
      geometry="primitive: plane">
    </a-plane>

    <!-- Simple “shark” made from primitives (visible only when in range) -->
    <a-entity id="shark" visible="false" position="0 -0.3 -3" rotation="0 20 0">
      <!-- bob animation -->
      <a-entity animation="property: position; to: 0 0.1 -3; dir: alternate; dur: 1200; loop: true; easing: easeInOutSine"></a-entity>

      <!-- body -->
      <a-cylinder radius="0.18" height="0.9" rotation="0 0 90" color="#7aa" position="0 0 0"></a-cylinder>
      <!-- nose -->
      <a-cone radius-bottom="0.18" radius-top="0.01" height="0.35" rotation="0 0 90" position="0.6 0 0" color="#7aa"></a-cone>
      <!-- tail -->
      <a-cone radius-bottom="0.22" radius-top="0.01" height="0.35" rotation="0 0 -90" position="-0.6 0 0" color="#7aa"></a-cone>

      <!-- dorsal fin -->
      <a-triangle
        vertex-a="0 0.2 0"
        vertex-b="-0.05 0 0.3"
        vertex-c="0.05 0 0.3"
        position="0 0.25 0"
        color="#688"></a-triangle>

      <!-- side fins -->
      <a-triangle
        vertex-a="0 0 0"
        vertex-b="-0.25 0 0.1"
        vertex-c="-0.25 0 -0.1"
        position="0 0 0.2"
        color="#688"></a-triangle>

      <a-triangle
        vertex-a="0 0 0"
        vertex-b="-0.25 0 0.1"
        vertex-c="-0.25 0 -0.1"
        position="0 0 -0.2"
        rotation="0 180 0"
        color="#688"></a-triangle>

      <!-- eyes -->
      <a-sphere radius="0.03" position="0.25 0.05 0.09" color="#000"></a-sphere>
      <a-sphere radius="0.03" position="0.25 0.05 -0.09" color="#000"></a-sphere>
    </a-entity>

    <a-entity light="type: ambient; intensity: 1.0"></a-entity>
  </a-scene>

  <script>
    (() => {
      // ---------------- CONFIG ----------------
      // For quick testing: auto-set target to your first GPS fix so shark appears immediately.
      const USE_FIRST_GPS_FIX_AS_TARGET = true;

      // Your fixed Target A (used if USE_FIRST_GPS_FIX_AS_TARGET = false)
      const TARGET_A = { lat: 37.3028, lon: -121.9982 };

      // Spawn radius
      const RADIUS_M = 30;

      const GEO_OPTS = { enableHighAccuracy: true, maximumAge: 1000, timeout: 15000 };

      // ---------------- ELEMENTS ----------------
      const hud = document.getElementById('hud');
      const startOverlay = document.getElementById('startOverlay');
      const startBtn = document.getElementById('startBtn');
      const video = document.getElementById('camVideo');
      const bgPlane = document.getElementById('bgPlane');
      const shark = document.getElementById('shark');
      const camEl = document.getElementById('cam');

      // ---------------- STATE ----------------
      let target = USE_FIRST_GPS_FIX_AS_TARGET ? null : { ...TARGET_A };
      let lastPos = null;
      let stream = null;
      let lastVideoTime = 0;

      // ---------------- HELPERS ----------------
      const pad = (n) => String(n).padStart(2, '0');
      const ts = () => {
        const d = new Date();
        return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
      };
      const fmt = (n, digits=6) => (n === null || n === undefined || Number.isNaN(n)) ? '—' : Number(n).toFixed(digits);

      function haversineMeters(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const toRad = (x) => x * Math.PI / 180;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function explainErr(err) {
        if (!err) return 'Unknown error';
        const parts = [];
        parts.push(`${err.name || 'Error'}: ${err.message || '(no message)'}`);
        if (err.constraint) parts.push(`constraint: ${err.constraint}`);
        if (err.code) parts.push(`code: ${err.code}`);
        return parts.join(' | ');
      }

      function isIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      }

      function resizeBgPlaneToVideo() {
        const w = video.videoWidth || 640;
        const h = video.videoHeight || 480;
        const aspect = w / h;

        const fovDeg = Number(camEl?.getAttribute('fov') || 80);
        const fov = fovDeg * Math.PI / 180;

        const dist = 10;
        const planeH = 2 * dist * Math.tan(fov / 2);
        const planeW = planeH * aspect;

        bgPlane.setAttribute('width', planeW);
        bgPlane.setAttribute('height', planeH);
      }

      async function startCamera() {
        if (!navigator.mediaDevices?.getUserMedia) {
          throw new Error('navigator.mediaDevices.getUserMedia is not available in this browser.');
        }

        // iOS: set these BEFORE play()
        video.muted = true;
        video.playsInline = true;
        video.setAttribute('playsinline', '');
        video.setAttribute('webkit-playsinline', '');
        video.autoplay = true;

        const constraints = {
          audio: false,
          video: {
            facingMode: { ideal: 'environment' },
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;

        // iOS often needs explicit play() inside the user gesture
        await video.play();

        // Wait briefly for dimensions
        await new Promise((resolve) => {
          if (video.readyState >= 1 && video.videoWidth) return resolve();
          const onLoaded = () => { video.removeEventListener('loadedmetadata', onLoaded); resolve(); };
          video.addEventListener('loadedmetadata', onLoaded);
          setTimeout(resolve, 1000);
        });

        resizeBgPlaneToVideo();
      }

      function startGeo() {
        if (!('geolocation' in navigator)) throw new Error('navigator.geolocation is not available.');

        navigator.geolocation.watchPosition(
          (pos) => {
            lastPos = pos;
            if (!target) target = { lat: pos.coords.latitude, lon: pos.coords.longitude };
            updateSpawn();
          },
          (err) => renderHud({ geoError: err }),
          GEO_OPTS
        );
      }

      function updateSpawn() {
        if (!lastPos || !target) return;
        const { latitude, longitude } = lastPos.coords;
        const d = haversineMeters(latitude, longitude, target.lat, target.lon);
        shark.setAttribute('visible', d <= RADIUS_M);
      }

      function cameraStatus() {
        const track = stream?.getVideoTracks?.()[0];
        const settings = track?.getSettings?.() || {};
        return {
          hasStream: !!stream,
          trackState: track ? track.readyState : 'none',
          trackLabel: track ? track.label : '—',
          enabled: track ? track.enabled : '—',
          muted: track ? track.muted : '—',
          vidReadyState: video.readyState, // 0..4
          vidPaused: video.paused,
          vidDims: `${video.videoWidth || 0}x${video.videoHeight || 0}`,
          currentTime: video.currentTime,
          settings
        };
      }

      function renderHud(extra = {}) {
        const cs = cameraStatus();
        const geo = lastPos?.coords;

        const nowTime = cs.currentTime || 0;
        const advancing = nowTime > lastVideoTime + 0.05;
        lastVideoTime = nowTime;

        const d = (geo && target)
          ? haversineMeters(geo.latitude, geo.longitude, target.lat, target.lon)
          : null;

        const lines = [
          `Mock WebAR Geo Spawn  |  ${ts()}`,
          `SecureContext: ${window.isSecureContext}   iOS: ${isIOS()}`,
          `URL: ${location.origin}${location.pathname}`,
          ``,
          `CAMERA`,
          `  stream: ${cs.hasStream ? 'OK' : 'none'}   trackState: ${cs.trackState}`,
          `  label: ${cs.trackLabel}`,
          `  video.readyState: ${cs.vidReadyState} (0..4)   paused: ${cs.vidPaused}`,
          `  video dims: ${cs.vidDims}   frames advancing: ${advancing ? 'YES' : 'NO'}`,
          `  currentTime: ${typeof cs.currentTime === 'number' ? cs.currentTime.toFixed(3) : cs.currentTime}`,
          `  settings: ${JSON.stringify(cs.settings)}`,
          extra.gumError ? `  getUserMedia ERROR: ${extra.gumError}` : ``,
          ``,
          `GEOLOCATION`,
          geo
            ? `  lat: ${fmt(geo.latitude)}  lon: ${fmt(geo.longitude)}  acc: ${Math.round(geo.accuracy)}m`
            : `  waiting for fix…`,
          target
            ? `  target: ${fmt(target.lat)}  ${fmt(target.lon)}  (mode: ${USE_FIRST_GPS_FIX_AS_TARGET ? 'first-fix' : 'fixed'})`
            : `  target: (not set yet)`,
          d !== null ? `  distance: ${Math.round(d)}m   radius: ${RADIUS_M}m   inRange: ${d <= RADIUS_M}` : ``,
          extra.geoError ? `  GEO ERROR: ${extra.geoError.code} ${extra.geoError.message}` : ``,
          ``,
          `NOTES`,
          `  If dims are 0x0 or frames advancing=NO: stream exists but isn't rendering.`,
          `  This page renders camera as a WebGL video texture (avoids iOS layer/z-index issues).`
        ].filter(Boolean);

        hud.textContent = lines.join('\n');
      }

      function startHudLoop() {
        const tick = () => { renderHud(); requestAnimationFrame(tick); };
        requestAnimationFrame(tick);
      }

      async function startAll() {
        startBtn.disabled = true;
        startBtn.textContent = 'Starting…';

        try {
          await startCamera();
        } catch (err) {
          renderHud({ gumError: explainErr(err) });
          throw err;
        }

        try {
          startGeo();
        } catch (err) {
          renderHud({ geoError: { code: 'init', message: String(err) } });
        }

        startOverlay.style.display = 'none';
      }

      // Show errors on-screen (huge help on iPhone without devtools)
      window.addEventListener('error', (e) => renderHud({ gumError: `JS ERROR: ${e.message}` }));
      window.addEventListener('unhandledrejection', (e) => renderHud({ gumError: `PROMISE REJECTION: ${explainErr(e.reason)}` }));

      startBtn.addEventListener('click', () => {
        startAll().catch(() => {
          startBtn.disabled = false;
          startBtn.textContent = 'Start Camera + GPS';
        });
      });

      // Keep HUD updating even before Start
      startHudLoop();
    })();
  </script>
</body>
</html>
