<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Marker + Geo Gate (Shark + Shadow)</title>

  <!-- AR.js 3.4.7 pairs well with A-Frame 1.6.0 -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/3.4.7/aframe/build/aframe-ar.js"></script>

  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #hud {
      position: fixed; top:0; left:0; z-index:50; padding:10px;
      color:#00ff66; font-size:12px; line-height:1.25; white-space:pre-wrap;
      text-shadow:0 0 3px rgba(0,0,0,.85); background:rgba(0,0,0,.35);
      max-width:92vw; max-height:70vh; overflow:auto; -webkit-overflow-scrolling:touch;
    }
    #startOverlay {
      position: fixed; inset:0; z-index:60; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.86); color:#fff;
    }
    #startOverlay .card { text-align:center; padding:20px; max-width:86vw; }
    #startOverlay button { font-size:18px; padding:14px 18px; border-radius:12px; border:0; margin-top:10px; min-width:260px; }
    #startOverlay .small { margin-top:12px; font-size:12px; opacity:.85; line-height:1.35; text-align:left; }

    #sceneHost { position: fixed; inset:0; z-index:10; }
    a-scene { position: fixed !important; inset:0 !important; }
  </style>
</head>

<body>
  <div id="hud">Loading…</div>

  <div id="startOverlay">
    <div class="card">
      <div style="font-size:18px; font-weight:600; margin-bottom:6px;">
        Marker mode with geo-gating
      </div>
      <button id="btnStart">Start (Camera + Location)</button>
      <div class="small">
        <div><b>markers/sjsu-logo.patt</b>: spawns shark anytime (no geo gate)</div>
        <div><b>markers/shark1.patt</b>: spawns shark only if within geo radius of Target A</div>
        <div style="margin-top:10px;">Tip: accept both <b>Camera</b> and <b>Location</b> prompts.</div>
      </div>
    </div>
  </div>

  <div id="sceneHost"></div>

  <script>
    (() => {
      // -------- Paths relative to index.html --------
      const SHADOW_IMG_URL   = "./assets/shadow.png";
      const MARKER_SJSU_URL  = "./markers/sjsu-logo.patt";
      const MARKER_SHARK_URL = "./markers/shark1.patt";

      // -------- Geo gate config --------
      const GEOFENCE_TARGET = { lat: 37.3028, lon: -121.9982 }; // Target A
      const GEOFENCE_RADIUS_M = 60;
      const USE_FIRST_GPS_FIX_AS_TARGET = false;
      const GEO_OPTS = { enableHighAccuracy: true, maximumAge: 1000, timeout: 15000 };

      // -------- Elements --------
      const hud = document.getElementById('hud');
      const overlay = document.getElementById('startOverlay');
      const btnStart = document.getElementById('btnStart');
      const sceneHost = document.getElementById('sceneHost');

      // -------- State --------
      let geoWatchId = null;
      let lastPos = null;

      let gateTarget = { ...GEOFENCE_TARGET };
      let distanceToGate = null;
      let inGate = false;

      let sjsuFound = false;
      let sharkFound = false;

      let arVideo = null; // AR.js injected video element

      // -------- Helpers --------
      const pad = (n) => String(n).padStart(2, '0');
      const ts = () => { const d = new Date(); return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; };
      const fmt = (n, digits=6) => (n === null || n === undefined || Number.isNaN(n)) ? '—' : Number(n).toFixed(digits);

      function haversineMeters(lat1, lon1, lat2, lon2) {
        const R = 6371000;
        const toRad = (x) => x * Math.PI / 180;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a =
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function isIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      }

      function explainErr(err) {
        if (!err) return 'Unknown error';
        const parts = [];
        parts.push(`${err.name || 'Error'}: ${err.message || '(no message)'}`);
        if (err.constraint) parts.push(`constraint: ${err.constraint}`);
        if (err.code) parts.push(`code: ${err.code}`);
        return parts.join(' | ');
      }

      async function requestOrientationPermissionIfNeeded() {
        try {
          if (typeof DeviceOrientationEvent !== 'undefined' &&
              typeof DeviceOrientationEvent.requestPermission === 'function') {
            await DeviceOrientationEvent.requestPermission();
          }
        } catch (_) {}
      }

      function stopGeoWatch() {
        if (geoWatchId !== null) {
          try { navigator.geolocation.clearWatch(geoWatchId); } catch (_) {}
          geoWatchId = null;
        }
      }

      function startGeoWatch() {
        stopGeoWatch();
        if (!('geolocation' in navigator)) throw new Error('navigator.geolocation not available.');

        geoWatchId = navigator.geolocation.watchPosition(
          (pos) => {
            lastPos = pos;

            if (USE_FIRST_GPS_FIX_AS_TARGET && gateTarget && gateTarget._unset !== false) {
              gateTarget = { lat: pos.coords.latitude, lon: pos.coords.longitude, _unset: false };
            }

            const { latitude, longitude } = pos.coords;
            distanceToGate = haversineMeters(latitude, longitude, gateTarget.lat, gateTarget.lon);
            inGate = distanceToGate <= GEOFENCE_RADIUS_M;

            updateMarkerVisibility();
          },
          (err) => renderHud({ geoError: err }),
          GEO_OPTS
        );
      }

      // -------- Shark + shadow prefab --------
      function createSharkEntityHTML() {
        // Use the <img id="shadowTex"> from a-assets (more reliable than url(...) in material)
        return `
          <a-entity class="sharkRoot" position="0 0 0" rotation="0 20 0">
            <a-plane
              class="sharkShadow"
              position="0 0.01 0"
              rotation="-90 0 0"
              width="1.4"
              height="1.4"
              material="shader: flat; src: #shadowTex; transparent: true; opacity: 0.65; alphaTest: 0.01; depthWrite: false">
            </a-plane>

            <a-cylinder radius="0.18" height="0.9" rotation="0 0 90" color="#7aa" position="0 0.25 0"></a-cylinder>
            <a-cone radius-bottom="0.18" radius-top="0.01" height="0.35" rotation="0 0 90" position="0.6 0.25 0" color="#7aa"></a-cone>
            <a-cone radius-bottom="0.22" radius-top="0.01" height="0.35" rotation="0 0 -90" position="-0.6 0.25 0" color="#7aa"></a-cone>

            <a-triangle
              vertex-a="0 0.2 0"
              vertex-b="-0.05 0 0.3"
              vertex-c="0.05 0 0.3"
              position="0 0.55 0"
              color="#688"></a-triangle>

            <a-sphere radius="0.03" position="0.25 0.32 0.09" color="#000"></a-sphere>
            <a-sphere radius="0.03" position="0.25 0.32 -0.09" color="#000"></a-sphere>
          </a-entity>
        `;
      }

      // -------- Marker scene --------
      function markerSceneHTML() {
        return `
          <a-scene
            id="markerScene"
            embedded
            vr-mode-ui="enabled:false"
            renderer="antialias:true; logarithmicDepthBuffer:true"
            arjs="sourceType: webcam; debugUIEnabled: false;">

            <a-assets>
              <img id="shadowTex" src="${SHADOW_IMG_URL}" crossorigin="anonymous" />
            </a-assets>

            <!-- SJSU marker (always spawns) -->
            <a-marker id="sjsuMarker"
              type="pattern"
              url="${MARKER_SJSU_URL}"
              emitevents="true"
              smooth="true" smoothCount="5" smoothTolerance="0.01" smoothThreshold="2">
              <a-entity id="sjsuShark" visible="false">
                <a-entity animation="property: position; to: 0 0.15 0; dir: alternate; dur: 1200; loop: true; easing: easeInOutSine"></a-entity>
                ${createSharkEntityHTML()}
              </a-entity>
            </a-marker>

            <!-- Shark marker (geo-gated) -->
            <a-marker id="sharkMarker"
              type="pattern"
              url="${MARKER_SHARK_URL}"
              emitevents="true"
              smooth="true" smoothCount="5" smoothTolerance="0.01" smoothThreshold="2">
              <a-entity id="sharkGateShark" visible="false">
                <a-entity animation="property: position; to: 0 0.15 0; dir: alternate; dur: 1200; loop: true; easing: easeInOutSine"></a-entity>
                ${createSharkEntityHTML()}
              </a-entity>
            </a-marker>

            <a-entity camera look-controls="enabled: false"></a-entity>
          </a-scene>
        `;
      }

      function hookMarkerEvents() {
        const sjsuMarker = document.getElementById('sjsuMarker');
        const sharkMarker = document.getElementById('sharkMarker');

        if (sjsuMarker) {
          sjsuMarker.addEventListener('markerFound', () => { sjsuFound = true; updateMarkerVisibility(); });
          sjsuMarker.addEventListener('markerLost',  () => { sjsuFound = false; updateMarkerVisibility(); });
        }
        if (sharkMarker) {
          sharkMarker.addEventListener('markerFound', () => { sharkFound = true; updateMarkerVisibility(); });
          sharkMarker.addEventListener('markerLost',  () => { sharkFound = false; updateMarkerVisibility(); });
        }

        // AR.js creates its own video; grab it for HUD
        setTimeout(() => {
          arVideo = document.querySelector('video.arjs-video') || document.querySelector('#arjs-video') || null;
        }, 700);
      }

      function updateMarkerVisibility() {
        const sjsuShark = document.getElementById('sjsuShark');
        const sharkGateShark = document.getElementById('sharkGateShark');
        if (!sjsuShark || !sharkGateShark) return;

        // Priority: SJSU marker wins if both markers are visible
        if (sjsuFound) {
          sjsuShark.setAttribute('visible', true);
          sharkGateShark.setAttribute('visible', false);
        } else {
          sjsuShark.setAttribute('visible', false);
          sharkGateShark.setAttribute('visible', sharkFound && inGate);
        }
      }

      // -------- HUD --------
      function cameraStatusMarker() {
        const v = arVideo;
        if (!v) return { hasVideo: false };
        return {
          hasVideo: true,
          readyState: v.readyState,
          paused: v.paused,
          dims: `${v.videoWidth || 0}x${v.videoHeight || 0}`,
        };
      }

      function renderHud(extra = {}) {
        const geo = lastPos?.coords;
        const cam = cameraStatusMarker();

        const lines = [
          `Marker + Geo Gate | ${ts()}`,
          `SecureContext: ${window.isSecureContext}   iOS: ${isIOS()}`,
          ``,
          `AR.js CAMERA`,
          `  arjs video: ${cam.hasVideo ? 'found' : 'not found yet'}`,
          cam.hasVideo ? `  readyState: ${cam.readyState} (0..4)   paused: ${cam.paused}` : ``,
          cam.hasVideo ? `  dims: ${cam.dims}` : ``,
          ``,
          `MARKERS`,
          `  sjsu-logo.patt found: ${sjsuFound}  -> shark visible: ${sjsuFound}`,
          `  shark1.patt found:    ${sharkFound}  -> shark visible: ${(!sjsuFound) && sharkFound && inGate}`,
          ``,
          `GEO GATE (for shark1.patt only)`,
          geo ? `  lat: ${fmt(geo.latitude)}  lon: ${fmt(geo.longitude)}  acc: ${Math.round(geo.accuracy)}m` : `  waiting for fix…`,
          `  gate target: ${fmt(gateTarget.lat)}  ${fmt(gateTarget.lon)}  ${USE_FIRST_GPS_FIX_AS_TARGET ? '(first-fix mode)' : '(fixed Target A)'}`,
          `  distance: ${distanceToGate === null ? '—' : Math.round(distanceToGate) + 'm'}   radius: ${GEOFENCE_RADIUS_M}m   inGate: ${inGate}`,
          extra.geoError ? `  GEO ERROR: ${extra.geoError.code} ${extra.geoError.message}` : ``,
          ``,
          `PATHS (relative to index.html)`,
          `  shadow: ${SHADOW_IMG_URL}`,
          `  sjsu marker: ${MARKER_SJSU_URL}`,
          `  shark marker: ${MARKER_SHARK_URL}`,
        ].filter(Boolean);

        hud.textContent = lines.join('\n');
      }

      function startHudLoop() {
        const tick = () => { renderHud(); requestAnimationFrame(tick); };
        requestAnimationFrame(tick);
      }

      // -------- Start --------
      async function start() {
        btnStart.disabled = true;
        btnStart.textContent = "Starting…";

        // Create the scene only after the tap (iOS camera gating)
        await requestOrientationPermissionIfNeeded();
        sceneHost.innerHTML = markerSceneHTML();
        hookMarkerEvents();

        // Start geolocation for the gate logic
        try {
          startGeoWatch();
        } catch (err) {
          renderHud({ geoError: { code: 'init', message: String(err) } });
        }

        overlay.style.display = 'none';
      }

      window.addEventListener('error', (e) => {
        hud.textContent = hud.textContent + `\n\nJS ERROR: ${e.message}`;
      });
      window.addEventListener('unhandledrejection', (e) => {
        hud.textContent = hud.textContent + `\n\nPROMISE REJECTION: ${explainErr(e.reason)}`;
      });

      btnStart.addEventListener('click', () => start().catch(() => {
        btnStart.disabled = false;
        btnStart.textContent = "Start (Camera + Location)";
      }));

      startHudLoop();
    })();
  </script>
</body>
</html>
