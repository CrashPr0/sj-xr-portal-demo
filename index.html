<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Marker Evolution – Cracks → Hole → Flaming Ball</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- AR.js -->
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.0/aframe/build/aframe-ar.js"></script>

  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #hud {
      position: fixed; top: 0; left: 0; right: 0;
      z-index: 20;
      background: rgba(0,0,0,0.55);
      color: #d7ffe9;
      font-size: 12px;
      padding: 10px 10px 8px;
      text-align: center;
      text-shadow: 0 0 3px rgba(0,0,0,0.8);
      pointer-events: none;
    }
    #controls {
      margin-top: 8px;
      display: inline-flex;
      gap: 8px;
      pointer-events: auto; /* buttons clickable */
    }
    .btn {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: #fff;
    }
    .btn.active {
      background: rgba(0,255,170,0.22);
      border-color: rgba(0,255,170,0.55);
    }
    #note { opacity: 0.9; margin-top: 4px; font-size: 11px; }
  </style>
</head>

<body>
  <div id="hud">
    <div id="status">Loading…</div>
    <div id="controls">
      <button class="btn active" data-mode="auto">Auto</button>
      <button class="btn" data-mode="1">Phase 1</button>
      <button class="btn" data-mode="2">Phase 2</button>
      <button class="btn" data-mode="3">Phase 3</button>
    </div>
    <div id="note">Scan the SJSU marker. Auto phases are based on March 28, 2026.</div>
  </div>

  <a-scene
    embedded
    vr-mode-ui="enabled:false"
    renderer="antialias:true; alpha:true; precision:mediump"
    arjs="sourceType: webcam; debugUIEnabled:false; patternRatio: 0.50;"
  >
    <a-assets>
      <!-- Swap these to match your repo -->
      <img id="texCracks" src="assets/cracks.png" crossorigin="anonymous" />
      <img id="texHole"   src="assets/hole.png" crossorigin="anonymous" />
      <img id="texBall"   src="assets/basketball.png" crossorigin="anonymous" />
      <img id="texFlame"  src="assets/flame.png" crossorigin="anonymous" />
    </a-assets>

    <!-- Lighting we can change by phase -->
    <a-entity id="ambientLight" light="type: ambient; intensity: 0.9; color: #ffffff"></a-entity>
    <a-entity id="dirLight" light="type: directional; intensity: 1.1; color: #ffffff" position="1 2 1"></a-entity>

    <!-- Marker -->
    <a-marker
      id="evoMarker"
      type="pattern"
      url="markers/sjsu-logo.patt"
      emitevents="true"
    >
      <!-- Root that we show/hide by phase -->
      <a-entity id="evoRoot" evolution-controller></a-entity>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>

  <script>
    // ---------- Config ----------
    const EVENT_DATE_LOCAL = "2026-03-28T18:00:00"; // local time; adjust if you want
    // Phase thresholds:
    // daysUntil > 14 => Phase 1
    // daysUntil > 7  => Phase 2
    // else           => Phase 3

    const GRACE_MS = 800; // keep visible briefly after markerLost

    // ---------- Utility ----------
    const statusEl = document.getElementById("status");
    const btns = Array.from(document.querySelectorAll(".btn"));

    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

    async function getServerNow() {
      // Harder to spoof than device time. Falls back if it fails.
      try {
        const r = await fetch(location.href, { method: "HEAD", cache: "no-store" });
        const d = r.headers.get("Date");
        if (d) return { now: new Date(d), source: "server" };
      } catch (_) {}
      return { now: new Date(), source: "device" };
    }

    function daysUntilEvent(now) {
      const event = new Date(EVENT_DATE_LOCAL);
      const ms = event.getTime() - now.getTime();
      return ms / (1000 * 60 * 60 * 24);
    }

    function phaseFromDays(days) {
      if (days > 14) return 1;
      if (days > 7) return 2;
      return 3;
    }

    function setActiveButton(mode) {
      btns.forEach(b => b.classList.toggle("active", b.dataset.mode === mode));
    }

    // ---------- Evolution Component ----------
    AFRAME.registerComponent("evolution-controller", {
      init: function () {
        this.marker = document.getElementById("evoMarker");
        this.root = this.el;

        // Build content once
        this.root.innerHTML = `
          <!-- Phase 1: cracks -->
          <a-plane id="cracksPlane"
            position="0 0.01 0"
            rotation="-90 0 0"
            width="1.8" height="1.8"
            material="shader: flat; src: #texCracks; transparent: true; opacity: 0.95; alphaTest: 0.02; depthWrite: false">
          </a-plane>

          <!-- Phase 2+: hole -->
          <a-plane id="holePlane"
            visible="false"
            position="0 0.012 0"
            rotation="-90 0 0"
            width="1.05" height="1.05"
            material="shader: flat; src: #texHole; transparent: true; opacity: 1.0; alphaTest: 0.02; depthWrite: false">
          </a-plane>

          <!-- Ball -->
          <a-entity id="ballRig" visible="false" position="0 0.05 0">
            <!-- Optional cheap outline: duplicate sphere slightly bigger, black, backfaces -->
            <a-sphere id="ballOutline" radius="0.155"
              material="shader: flat; color: #000; side: back"
              scale="1.06 1.06 1.06"
              visible="false">
            </a-sphere>

            <a-sphere id="ball"
              radius="0.15"
              material="shader: standard; src: #texBall; roughness: 0.85; metalness: 0.05;">
            </a-sphere>

            <!-- Phase 3 flame aura -->
            <a-entity id="flames" visible="false">
              ${[0,60,120,180,240,300].map((deg,i)=>`
                <a-plane class="flameSprite"
                  rotation="0 ${deg} 0"
                  position="0 0 -0.17"
                  width="0.35" height="0.55"
                  material="shader: flat; src: #texFlame; transparent: true; opacity: 0.9; alphaTest: 0.02; depthWrite: false; side: double;">
                </a-plane>
              `).join("")}
            </a-entity>

            <!-- Phase 3: warm point light -->
            <a-entity id="ballLight" visible="false"
              light="type: point; intensity: 1.2; distance: 3.5; color: #ff7a2a"
              position="0 0.1 0">
            </a-entity>
          </a-entity>
        `;

        // Cache nodes
        this.cracksPlane = this.root.querySelector("#cracksPlane");
        this.holePlane = this.root.querySelector("#holePlane");
        this.ballRig = this.root.querySelector("#ballRig");
        this.ball = this.root.querySelector("#ball");
        this.ballOutline = this.root.querySelector("#ballOutline");
        this.flames = this.root.querySelector("#flames");
        this.ballLight = this.root.querySelector("#ballLight");

        this.ambient = document.getElementById("ambientLight");
        this.dir = document.getElementById("dirLight");

        this.visible = false;
        this.hideTimer = null;

        // Mode: "auto" or "1"/"2"/"3"
        this.mode = "auto";
        this.currentPhase = 1;
        this.timeSource = "device";
        this.days = null;

        // Marker events
        if (this.marker) {
          this.marker.addEventListener("markerFound", () => this.onFound());
          this.marker.addEventListener("markerLost", () => this.onLost());
        }

        // UI buttons
        btns.forEach(btn => {
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            this.setMode(btn.dataset.mode);
          });
        });

        // Initial compute
        this.refreshPhase(true);

        // Periodic refresh (auto mode)
        setInterval(() => {
          if (this.mode === "auto") this.refreshPhase(false);
        }, 60 * 1000);
      },

      async refreshPhase(force) {
        if (this.mode !== "auto") {
          this.currentPhase = parseInt(this.mode, 10) || 1;
          this.days = null;
          this.timeSource = "manual";
          this.applyPhaseVisuals(force);
          this.updateHud();
          return;
        }

        const { now, source } = await getServerNow();
        this.timeSource = source;
        this.days = daysUntilEvent(now);
        const nextPhase = phaseFromDays(this.days);

        if (force || nextPhase !== this.currentPhase) {
          this.currentPhase = nextPhase;
          this.applyPhaseVisuals(true);
        }
        this.updateHud();
      },

      setMode(mode) {
        this.mode = mode;
        setActiveButton(mode);
        this.refreshPhase(true);
      },

      updateHud() {
        const d = this.days;
        const daysStr = (d == null) ? "—" : (d.toFixed(1) + " days");
        statusEl.textContent =
          `Mode: ${this.mode.toUpperCase()} | Phase: ${this.currentPhase} | Until Mar 28: ${daysStr} | Time: ${this.timeSource}` +
          (this.visible ? " | Marker: FOUND" : " | Marker: LOST");
      },

      applyPhaseVisuals(force) {
        // Cracks always visible
        this.cracksPlane.setAttribute("visible", true);

        // Hole + ball only in phase 2+
        const p = this.currentPhase;
        this.holePlane.setAttribute("visible", p >= 2);

        // Ball rig exists but is shown only when marker is found (so it can animate out)
        // We still set per-phase settings now.
        // Phase-specific lighting
        if (p === 1) {
          this.setSceneLighting({ ambientI: 0.95, ambientC: "#ffffff", dirI: 1.1, dirC: "#ffffff" });
        } else if (p === 2) {
          this.setSceneLighting({ ambientI: 0.85, ambientC: "#f4fbff", dirI: 1.05, dirC: "#ffffff" });
        } else {
          // Phase 3: warmer, punchier
          this.setSceneLighting({ ambientI: 0.55, ambientC: "#2b2a40", dirI: 1.25, dirC: "#ffd2a3" });
        }

        // Flames/ballLight only for phase 3
        this.flames.setAttribute("visible", p === 3 && this.visible);
        this.ballLight.setAttribute("visible", p === 3 && this.visible);

        // Optional outline only for phase 3 (more “toon”)
        this.ballOutline.setAttribute("visible", p === 3 && this.visible);
      },

      setSceneLighting({ ambientI, ambientC, dirI, dirC }) {
        if (!this.ambient || !this.dir) return;
        this.ambient.setAttribute("light", "intensity", ambientI);
        this.ambient.setAttribute("light", "color", ambientC);
        this.dir.setAttribute("light", "intensity", dirI);
        this.dir.setAttribute("light", "color", dirC);
      },

      onFound() {
        this.visible = true;
        this.updateHud();

        if (this.hideTimer) {
          clearTimeout(this.hideTimer);
          this.hideTimer = null;
        }

        // Phase 1: no ball, just cracks
        if (this.currentPhase === 1) {
          this.ballRig.setAttribute("visible", false);
          this.holePlane.setAttribute("visible", false);
          return;
        }

        // Phase 2+:
        this.holePlane.setAttribute("visible", true);
        this.ballRig.setAttribute("visible", true);

        // Reset ball start state “inside hole”
        this.ballRig.setAttribute("position", "0 -0.18 0");
        this.ballRig.setAttribute("rotation", "0 0 0");
        this.ballRig.setAttribute("scale", "1 1 1");

        // Configure animation per phase
        const isPhase3 = this.currentPhase === 3;

        // Fly-out animation
        const flyDur = isPhase3 ? 520 : 1200;
        const flyToY = isPhase3 ? 0.55 : 0.45;

        this.ballRig.setAttribute("animation__fly", `
          property: position;
          from: 0 -0.18 0;
          to: 0 ${flyToY} 0;
          dur: ${flyDur};
          easing: ${isPhase3 ? "easeOutBack" : "easeOutCubic"};
        `);

        // Spin animation
        const spinDur = isPhase3 ? 2200 : 6000;
        this.ballRig.setAttribute("animation__spin", `
          property: rotation;
          to: 0 360 0;
          loop: true;
          dur: ${spinDur};
          easing: linear;
        `);

        // Little “breathing” hover
        this.ballRig.setAttribute("animation__hover", `
          property: position;
          dir: alternate;
          loop: true;
          dur: ${isPhase3 ? 900 : 1400};
          easing: easeInOutSine;
          to: 0 ${flyToY + 0.05} 0;
        `);

        // Flames + point light only in phase 3
        this.flames.setAttribute("visible", isPhase3);
        this.ballLight.setAttribute("visible", isPhase3);
        this.ballOutline.setAttribute("visible", isPhase3);

        // Flame sprite flicker (cheap)
        if (isPhase3) {
          const sprites = this.root.querySelectorAll(".flameSprite");
          sprites.forEach((s, i) => {
            s.setAttribute("animation__flicker", `
              property: material.opacity;
              from: 0.55;
              to: 0.95;
              dir: alternate;
              loop: true;
              dur: ${clamp(250 + i * 35, 250, 520)};
              easing: easeInOutSine;
            `);
          });
        }
      },

      onLost() {
        this.visible = false;
        this.updateHud();

        // Grace period then hide ball & extras
        if (this.hideTimer) clearTimeout(this.hideTimer);
        this.hideTimer = setTimeout(() => {
          this.ballRig.setAttribute("visible", false);
          this.flames.setAttribute("visible", false);
          this.ballLight.setAttribute("visible", false);
          this.ballOutline.setAttribute("visible", false);

          // Keep cracks visible, hide hole when not found (optional)
          this.holePlane.setAttribute("visible", false);
        }, GRACE_MS);
      }
    });
  </script>
</body>
</html>
